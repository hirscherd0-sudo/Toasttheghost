<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Toast the Ghost - Multiplayer</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Courier New', Courier, monospace; }
        #game-container { position: relative; width: 100vw; height: 100vh; display: none; } 
        
        /* --- LOBBY STYLES --- */
        #lobby-container {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: #111;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            color: white;
            background-image: radial-gradient(circle at center, #222 0%, #000 100%);
        }
        
        .title-logo {
            font-size: 50px;
            color: #ffcc00;
            text-shadow: 4px 4px 0px #a00, 0 0 20px #ff0000;
            font-weight: 900;
            letter-spacing: 5px;
            margin-bottom: 40px;
            text-align: center;
            text-transform: uppercase;
        }

        .lobby-input {
            padding: 15px;
            font-size: 18px;
            margin: 10px;
            background: #222;
            border: 2px solid #555;
            color: #fff;
            width: 250px;
            text-align: center;
            border-radius: 5px;
        }
        .lobby-input:focus { border-color: #ffcc00; outline: none; }

        .lobby-btn {
            padding: 15px 30px;
            font-size: 20px;
            background: #a00;
            color: white;
            border: none;
            cursor: pointer;
            margin-top: 30px;
            border-radius: 8px;
            font-weight: bold;
            box-shadow: 0 4px 0 #500;
            transition: transform 0.1s;
        }
        .lobby-btn:hover { background: #c00; }
        .lobby-btn:active { transform: translateY(4px); box-shadow: 0 0 0 #500; }
        
        .char-grid {
            display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px; margin: 20px;
        }
        .char-select {
            padding: 15px; border: 2px solid #444; cursor: pointer; text-align: center;
            background: #1a1a1a; border-radius: 5px;
        }
        .char-select:hover { border-color: #888; }
        .char-select.selected { border-color: #ffcc00; background: #333; box-shadow: 0 0 10px #ffcc00; }

        /* --- GAME UI --- */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 5; }
        #stats-container { position: absolute; top: 20px; left: 20px; display: flex; flex-direction: column; gap: 5px; }
        .stat-text { color: #ffcc00; font-size: 24px; text-shadow: 2px 2px 0 #000; font-weight: bold; }
        
        #status-message {
            position: absolute; top: 20%; left: 50%; transform: translateX(-50%);
            color: #00ffff; font-size: 24px; font-weight: bold; text-shadow: 0 0 10px #0000ff;
            display: none; text-align: center; background: rgba(0,0,0,0.7);
            padding: 15px; border: 2px solid #00ffff; border-radius: 8px;
        }
        
        #minimap-container {
            position: absolute; top: 20px; right: 20px; width: 200px; height: 150px;
            border: 4px solid #888; background: #222; pointer-events: none;
        }
        
        /* Joystick */
        #joystick-zone {
            position: absolute; bottom: 50px; left: 50px; width: 120px; height: 120px;
            background: rgba(255, 255, 255, 0.1); border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.3); pointer-events: auto; touch-action: none; z-index: 10;
        }
        #joystick-knob {
            position: absolute; top: 50%; left: 50%; width: 50px; height: 50px;
            background: rgba(200, 200, 200, 0.5); border-radius: 50%;
            transform: translate(-50%, -50%); pointer-events: none;
        }
        
        /* Labels für andere Spieler */
        .player-label {
            position: absolute; color: white; background: rgba(0,0,0,0.5); padding: 2px 5px;
            font-size: 12px; pointer-events: none; border-radius: 4px; display: none;
        }
    </style>
</head>
<body>

<!-- LOBBY -->
<div id="lobby-container">
    <div class="title-logo">TOAST THE GHOST</div>
    <div style="color: #aaa; margin-bottom: 20px;">MULTIPLAYER EDITION</div>
    
    <input type="text" id="username-input" class="lobby-input" placeholder="Dein Name" maxlength="10">
    <input type="text" id="room-input" class="lobby-input" placeholder="Raum Name (z.B. 'Keller')" maxlength="10">

    <h3 style="margin-top: 20px;">Wähle deinen Geisterjäger:</h3>
    <div class="char-grid">
        <div class="char-select selected" onclick="selectLobbyChar('ramona', this)">Ramona</div>
        <div class="char-select" onclick="selectLobbyChar('pia', this)">Pia</div>
        <div class="char-select" onclick="selectLobbyChar('sophie', this)">Sophie</div>
        <div class="char-select" onclick="selectLobbyChar('johnny', this)">Johnny</div>
        <div class="char-select" onclick="selectLobbyChar('sebi', this)">Sebi</div>
    </div>

    <button class="lobby-btn" onclick="joinGame()">STARTEN</button>
</div>

<!-- GAME -->
<div id="game-container">
    <div id="ui-layer">
        <div id="stats-container">
            <div id="score-text" class="stat-text">Punkte: 0</div>
            <div id="level-text" class="stat-text">Level: 1</div>
        </div>
        <div id="minimap-container"></div>
        <div id="status-message"></div>
    </div>
    <div id="joystick-zone"><div id="joystick-knob"></div></div>
</div>

<script src="/socket.io/socket.io.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

<script>
// --- SOCKET & LOBBY LOGIC ---
const socket = io();
let myRoomId = null;
let myClientId = null;
let selectedCharKey = 'ramona';
let isHost = false; 

const remotePlayers = {}; 

function selectLobbyChar(key, elem) {
    selectedCharKey = key;
    document.querySelectorAll('.char-select').forEach(el => el.classList.remove('selected'));
    elem.classList.add('selected');
}

function joinGame() {
    const username = document.getElementById('username-input').value.trim() || "Jäger";
    const room = document.getElementById('room-input').value.trim() || "Spukhaus";
    myRoomId = room;

    document.getElementById('lobby-container').style.display = 'none';
    document.getElementById('game-container').style.display = 'block';

    socket.emit('joinRoom', { room, character: selectedCharKey, username });
    initGame();
}

// --- NETWORK EVENT HANDLERS ---
socket.on('currentRoomState', (roomState) => {
    for (const id in roomState.players) {
        if (id !== socket.id) {
            spawnRemotePlayer(id, roomState.players[id]);
        }
    }
    currentState.level = roomState.level;
    roomState.pelletsRemoved.forEach(idx => {
        const p = pellets.find(pel => pel.userData.index === idx);
        if(p) { scene.remove(p); p.visible = false; }
    });
    roomState.crucifixesRemoved.forEach(idx => {
        const c = crucifixes.find(cru => cru.userData.index === idx);
        if(c) { scene.remove(c); c.visible = false; }
    });
    if (roomState.hostId === socket.id) isHost = true;
});

socket.on('playerJoined', (playerData) => {
    spawnRemotePlayer(playerData.id, playerData);
});

socket.on('playerMoved', (data) => {
    if (remotePlayers[data.id]) {
        const rp = remotePlayers[data.id];
        rp.targetPos = { x: data.x, z: data.z, rot: data.rotation };
    }
});

socket.on('playerLeft', (id) => {
    if (remotePlayers[id]) {
        scene.remove(remotePlayers[id].mesh);
        if(remotePlayers[id].label) remotePlayers[id].label.remove();
        delete remotePlayers[id];
    }
});

socket.on('youAreHost', () => { isHost = true; });

socket.on('ghostsUpdated', (ghostsData) => {
    if (!isHost) {
        for (let i = 0; i < ghostsData.length; i++) {
            if (ghosts[i]) {
                ghosts[i].position.x = ghostsData[i].x;
                ghosts[i].position.z = ghostsData[i].z;
            }
        }
    }
});

socket.on('itemRemoved', ({ type, index }) => {
    if (type === 'pellet') {
        const p = pellets.find(pel => pel.userData.index === index);
        if(p && p.visible) {
            scene.remove(p); p.visible = false;
            currentState.score += 10; updateScoreUI();
        }
    } else if (type === 'crucifix') {
        const c = crucifixes.find(cru => cru.userData.index === index);
        if(c && c.visible) {
            scene.remove(c); c.visible = false;
        }
    }
});

socket.on('powerModeActivated', () => { activatePowerModeVisuals(); });

socket.on('ghostDied', ({ ghostId }) => {
    if (ghosts[ghostId] && ghosts[ghostId].visible) {
        spawnDeathParticles(ghosts[ghostId].position.x, ghosts[ghostId].position.z);
        scene.remove(ghosts[ghostId]);
        ghosts[ghostId].visible = false; 
    }
});

socket.on('startNextLevel', ({ level }) => {
    currentState.level = level;
    startLevel();
});


// --- GAME ENGINE ---
const CONFIG = {
    moveSpeed: 0.15,
    baseGhostSpeed: 0.025,
    maxGhostSpeed: 0.12,
    powerModeDuration: 8000,
    wallSize: 4,
    playerRadius: 0.8,
    cameraHeight: 14,
    cameraDistance: 11,
    minimapZoom: 75 
};

// Maps (10 Layouts)
const MAPS = [
    [
        [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
        [1,8,0,0,0,0,1,0,0,0,0,0,8,0,1],
        [1,0,1,1,1,0,1,0,1,1,1,1,1,0,1],
        [1,0,1,0,0,0,0,0,0,0,0,0,1,0,1],
        [1,0,1,0,1,1,0,1,1,1,1,0,1,0,1],
        [1,0,0,0,0,0,9,0,0,0,0,0,0,0,1],
        [1,0,1,0,1,1,1,1,1,0,1,1,1,0,1],
        [1,0,1,0,0,0,1,0,0,0,1,0,0,0,1],
        [1,0,1,1,1,0,1,0,1,0,1,0,1,1,1],
        [1,8,0,0,0,0,0,0,1,0,0,0,0,8,1],
        [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
    ],
    [[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,8,0,0,0,1,1,1,1,1,0,0,0,8,1],[1,0,1,1,0,0,0,0,0,0,0,1,1,0,1],[1,0,1,0,0,1,0,1,0,1,0,0,1,0,1],[1,0,0,0,1,0,0,9,0,0,1,0,0,0,1],[1,0,1,0,0,0,0,1,0,0,0,0,1,0,1],[1,0,1,1,0,1,0,1,0,1,0,1,1,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,1,0,1,1,1,0,1,0,1,1,1,0,1,1],[1,8,0,0,0,0,0,1,0,0,0,0,0,8,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]],
    [[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,8,0,1,0,0,0,1,0,0,0,1,0,8,1],[1,0,0,1,0,1,0,1,0,1,0,1,0,0,1],[1,0,0,1,0,1,0,0,0,1,0,1,0,0,1],[1,0,0,0,0,1,1,0,1,1,0,0,0,0,1],[1,1,1,1,0,0,0,9,0,0,0,1,1,1,1],[1,0,0,0,0,1,1,0,1,1,0,0,0,0,1],[1,0,0,1,0,1,0,0,0,1,0,1,0,0,1],[1,0,0,1,0,1,0,1,0,1,0,1,0,0,1],[1,8,0,1,0,0,0,1,0,0,0,1,0,8,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]],
    [[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,8,0,0,0,0,0,1,0,0,0,0,0,8,1],[1,1,1,1,1,1,0,1,0,1,1,1,1,1,1],[1,0,0,0,0,0,0,1,0,0,0,0,0,0,1],[1,0,1,1,1,1,0,0,0,1,1,1,1,0,1],[1,0,1,9,0,0,0,1,0,0,0,0,1,0,1],[1,0,1,1,1,1,0,0,0,1,1,1,1,0,1],[1,0,0,0,0,0,0,1,0,0,0,0,0,0,1],[1,1,1,1,1,1,0,1,0,1,1,1,1,1,1],[1,8,0,0,0,0,0,1,0,0,0,0,0,8,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]],
    [[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,8,0,1,0,0,0,1,0,0,0,1,0,8,1],[1,0,0,1,0,1,0,0,0,1,0,1,0,0,1],[1,1,0,1,0,1,1,1,1,1,0,1,0,1,1],[1,0,0,0,0,0,0,1,0,0,0,0,0,0,1],[1,0,1,1,0,1,0,9,0,1,0,1,1,0,1],[1,0,0,0,0,1,0,0,0,1,0,0,0,0,1],[1,1,0,1,0,1,1,1,1,1,0,1,0,1,1],[1,0,0,1,0,0,0,0,0,0,0,1,0,0,1],[1,8,0,1,1,1,0,1,0,1,1,1,0,8,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]],
    [[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,8,0,0,0,0,0,1,0,0,0,0,0,8,1],[1,0,1,1,1,1,0,1,0,1,1,1,1,0,1],[1,0,1,0,0,0,0,1,0,0,0,0,1,0,1],[1,0,1,0,1,0,0,9,0,0,1,0,1,0,1],[1,0,0,0,1,1,1,0,1,1,1,0,0,0,1],[1,0,1,0,1,0,0,0,0,0,1,0,1,0,1],[1,0,1,0,0,0,0,1,0,0,0,0,1,0,1],[1,0,1,1,1,1,0,1,0,1,1,1,1,0,1],[1,8,0,0,0,0,0,1,0,0,0,0,0,8,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]],
    [[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,8,0,1,0,0,0,0,0,0,0,0,0,8,1],[1,0,0,1,0,1,1,1,1,1,0,1,1,1,1],[1,0,0,1,0,0,0,0,0,1,0,0,0,0,1],[1,1,0,1,1,1,1,1,0,1,1,1,1,0,1],[1,0,0,0,0,0,0,0,0,9,0,0,0,0,1],[1,0,1,1,1,0,1,1,1,1,0,1,0,1,1],[1,0,0,0,0,0,1,0,0,0,0,1,0,0,1],[1,1,1,1,0,1,1,0,1,0,0,1,0,0,1],[1,8,0,0,0,0,0,0,1,0,0,0,0,8,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]],
    [[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,8,0,0,0,0,0,0,0,0,0,0,0,8,1],[1,0,1,0,1,0,1,0,1,0,1,0,1,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,1,0,1,0,1,9,1,0,1,0,1,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,1,0,1,0,1,0,1,0,1,0,1,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,1,0,1,0,1,0,1,0,1,0,1,0,1],[1,8,0,0,0,0,0,0,0,0,0,0,0,8,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]],
    [[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,8,0,0,0,0,0,0,0,0,0,0,0,8,1],[1,0,1,1,1,1,1,1,1,1,1,1,1,0,1],[1,0,1,0,0,0,0,0,0,0,0,0,1,0,1],[1,0,1,0,1,1,1,1,1,1,1,0,1,0,1],[1,0,1,0,1,0,0,9,0,0,1,0,1,0,1],[1,0,1,0,1,1,1,0,1,1,1,0,1,0,1],[1,0,1,0,0,0,0,0,0,0,0,0,1,0,1],[1,0,1,1,1,1,1,1,1,1,1,1,1,0,1],[1,8,0,0,0,0,0,0,0,0,0,0,0,8,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]],
    [[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,8,0,0,0,0,0,1,0,0,0,0,0,8,1],[1,0,0,0,0,0,0,1,0,0,0,0,0,0,1],[1,0,0,1,1,0,0,1,0,0,1,1,0,0,1],[1,0,0,1,0,0,0,1,0,0,0,1,0,0,1],[1,1,0,0,0,0,0,9,0,0,0,0,0,1,1],[1,0,0,1,0,0,0,1,0,0,0,1,0,0,1],[1,0,0,1,1,0,0,1,0,0,1,1,0,0,1],[1,0,0,0,0,0,0,1,0,0,0,0,0,0,1],[1,8,0,0,0,0,0,1,0,0,0,0,0,8,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]]
];

const CHARACTERS = {
    ramona: { skin: 0xeebb99, shirt: 0x008080, shorts: 0x3d2314, hair: 0x3d2314, type: 'female_pony' },
    pia:    { skin: 0xffdbac, shirt: 0x800080, shorts: 0x111111, hair: 0xffffaa, type: 'female_pony' },
    sophie: { skin: 0xffe0bd, shirt: 0x00aa00, shorts: 0x222222, hair: 0xaa4400, type: 'female_pony' },
    johnny: { skin: 0xeebb99, shirt: 0xffffff, shorts: 0x2a2a2a, hair: 0x222222, type: 'male_curly_braces' },
    sebi:   { skin: 0xd2b48c, shirt: 0xff69b4, shorts: 0x444444, hair: 0x111111, type: 'male_buzz' }
};

let currentState = { level: 1, score: 0 };
let scene, camera, renderer, mapCamera, mapRenderer, mapLight;
let player, ghosts = [], walls = [], pellets = [], crucifixes = [], particles = [];
let joystickData = { x: 0, y: 0, active: false };
let playerParts = { group: null }; 

// Init ThreeJS
function initGame() {
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x050505);
    scene.fog = new THREE.FogExp2(0x050505, 0.035);

    camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
    
    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    document.getElementById('game-container').prepend(renderer.domElement);

    setupMinimap();
    scene.add(new THREE.AmbientLight(0x202020));
    const dirLight = new THREE.DirectionalLight(0xffffff, 0.4);
    dirLight.position.set(50, 100, 50); dirLight.castShadow = true; scene.add(dirLight);

    setupJoystick();
    window.addEventListener('resize', onWindowResize, false);
    
    startLevel();
    animate();
}

function setupMinimap() {
    const frustumSize = CONFIG.minimapZoom;
    mapCamera = new THREE.OrthographicCamera(frustumSize * 1.33 / -2, frustumSize * 1.33 / 2, frustumSize / 2, frustumSize / -2, 1, 100);
    mapCamera.position.set(30, 50, 22); mapCamera.lookAt(30, 0, 22);
    
    mapRenderer = new THREE.WebGLRenderer({ antialias: false });
    mapRenderer.setSize(200, 150);
    document.getElementById('minimap-container').appendChild(mapRenderer.domElement);
    mapLight = new THREE.AmbientLight(0xffffff, 3.0); 
}

function startLevel() {
    while(scene.children.length > 0){ scene.remove(scene.children[0]); }
    ghosts = []; walls = []; pellets = []; crucifixes = []; particles = [];
    
    scene.add(new THREE.AmbientLight(0x202020));
    const dirLight = new THREE.DirectionalLight(0xffffff, 0.4);
    dirLight.position.set(50, 100, 50); dirLight.castShadow = true; scene.add(dirLight);

    document.getElementById('level-text').innerText = "Level: " + currentState.level;
    
    const mapLayout = MAPS[(currentState.level - 1) % MAPS.length];
    createLevelGeometry(mapLayout);

    for (const id in remotePlayers) {
        const rp = remotePlayers[id];
        const mesh = createCharacterMesh(CHARACTERS[rp.data.character]);
        mesh.position.set(rp.targetPos?.x || 0, 0, rp.targetPos?.z || 0);
        rp.mesh = mesh;
        scene.add(mesh);
    }
}

function createCharacterMesh(charData) {
    const group = new THREE.Group();
    const mat = new THREE.MeshStandardMaterial({ color: charData.shirt });
    const skinMat = new THREE.MeshStandardMaterial({ color: charData.skin });
    const hairMat = new THREE.MeshStandardMaterial({ color: charData.hair });

    const body = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.7, 0.35), mat);
    body.position.y = 1.35; body.castShadow = true;
    group.add(body);
    
    const head = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.45, 0.4), skinMat);
    head.position.y = 1.75; head.castShadow = true;
    group.add(head);

    // Frisur
    if (charData.type === 'female_pony') {
        const hairTop = new THREE.Mesh(new THREE.BoxGeometry(0.42, 0.15, 0.42), hairMat);
        hairTop.position.y = 1.95; group.add(hairTop);
        const hairBack = new THREE.Mesh(new THREE.BoxGeometry(0.42, 0.5, 0.15), hairMat);
        hairBack.position.set(0, 1.75, -0.18); group.add(hairBack);
        const pony = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.6, 0.15), hairMat);
        pony.position.set(0, 1.5, -0.25); pony.rotation.x = 0.2; group.add(pony);
    } else if (charData.type === 'male_curly_braces') {
        const h = new THREE.Mesh(new THREE.BoxGeometry(0.45, 0.2, 0.45), hairMat);
        h.position.y=2.0; group.add(h);
    } else if (charData.type === 'male_buzz') {
        const h = new THREE.Mesh(new THREE.BoxGeometry(0.41, 0.05, 0.41), hairMat);
        h.position.y=1.98; group.add(h);
    }
    
    const l = new THREE.PointLight(0xffaa55, 0.5, 10);
    l.position.set(0, 2, 0.5);
    group.add(l);
    
    return group;
}

function spawnRemotePlayer(id, data) {
    if(remotePlayers[id]) return; 
    const charData = CHARACTERS[data.character] || CHARACTERS['ramona'];
    const mesh = createCharacterMesh(charData);
    mesh.position.set(data.x, 0, data.z);
    
    const div = document.createElement('div');
    div.className = 'player-label';
    div.innerText = data.username;
    document.body.appendChild(div);

    remotePlayers[id] = { mesh: mesh, data: data, label: div, targetPos: { x: data.x, z: data.z, rot: data.rotation } };
    scene.add(mesh);
}

function spawnDeathParticles(x, z) {
    for(let i=0; i<10; i++) {
        const p = new THREE.Mesh(new THREE.BoxGeometry(0.2,0.2,0.2), new THREE.MeshBasicMaterial({color:0x00ffff}));
        p.position.set(x,1,z);
        p.userData={vx:(Math.random()-0.5)*0.3, vy:Math.random()*0.3, vz:(Math.random()-0.5)*0.3, life:1.0};
        scene.add(p); particles.push(p);
    }
}

function createLevelGeometry(layout) {
    const floor = new THREE.Mesh(new THREE.PlaneGeometry(100, 100), new THREE.MeshStandardMaterial({color:0x111111}));
    floor.rotation.x = -Math.PI/2;
    scene.add(floor);

    player = createCharacterMesh(CHARACTERS[selectedCharKey]);
    playerParts.group = player; 
    scene.add(player);
    
    let pelletIndex = 0;
    for(let z=0; z<layout.length; z++){
        for(let x=0; x<layout[z].length; x++){
            const t = layout[z][x];
            const px = x*CONFIG.wallSize, pz = z*CONFIG.wallSize;
            if(t===1) {
                const w = new THREE.Mesh(new THREE.BoxGeometry(4,6,4), new THREE.MeshStandardMaterial({color:0x888888}));
                w.position.set(px,0,pz);
                w.userData = { box: new THREE.Box3().setFromObject(w) };
                scene.add(w); walls.push(w);
            } else if(t===0) {
                const p = new THREE.Mesh(new THREE.SphereGeometry(0.3), new THREE.MeshBasicMaterial({color:0x00ff00}));
                p.position.set(px,-1,pz);
                p.userData = { index: pelletIndex++ };
                scene.add(p); pellets.push(p);
            } else if(t===8) {
                 const group = new THREE.Group();
                const m = new THREE.MeshStandardMaterial({ color: 0xffd700, emissive: 0xaa8800 });
                group.add(new THREE.Mesh(new THREE.BoxGeometry(0.4, 1.8, 0.2), m));
                const h = new THREE.Mesh(new THREE.BoxGeometry(1.2, 0.4, 0.2), m); h.position.y=0.3; group.add(h);
                group.position.set(px,0,pz);
                group.userData = { index: pelletIndex++ }; // Share index pool
                scene.add(group); crucifixes.push(group);
            } else if(t===9) {
                player.position.set(px,0,pz);
            }
        }
    }

    // Geister Placeholders
    for(let i=0; i<4; i++) {
        const gGroup = new THREE.Group();
        const gBody = new THREE.Mesh(new THREE.BoxGeometry(0.6,1.4,0.35), new THREE.MeshStandardMaterial({color:0xeeeeee}));
        gBody.position.y=0.7; gBody.name="ghostPart"; gGroup.add(gBody);
        const gHead = new THREE.Mesh(new THREE.BoxGeometry(0.5,0.5,0.5), new THREE.MeshStandardMaterial({color:0xd0d0d0}));
        gHead.position.y=1.65; gHead.name="ghostPart"; gGroup.add(gHead);
        // Hair
        const hair = new THREE.Mesh(new THREE.BoxGeometry(0.52,0.8,0.15), new THREE.MeshStandardMaterial({color:0x000000}));
        hair.position.set(0,1.5,-0.26); gGroup.add(hair);

        gGroup.position.set(0,-20,0);
        scene.add(gGroup);
        ghosts.push(gGroup);
    }
}

// --- UPDATE LOOPS ---

function updateScoreUI() {
    document.getElementById('score-text').innerText = "Punkte: " + currentState.score;
}

function activatePowerModeVisuals() {
    const msg = document.getElementById('status-message');
    msg.innerHTML = "KRUZIFIX AKTIV!<br>TOAST THE GHOST!";
    msg.style.display = 'block';
    
    ghosts.forEach(g => {
        g.traverse(c => { if(c.name==="ghostPart") c.material.color.setHex(0x3333ff); });
    });

    setTimeout(() => { 
        msg.style.display = 'none'; 
        ghosts.forEach(g => {
            g.traverse(c => { 
                if(c.name==="ghostPart") {
                    // Reset to white/grey
                    if(c.geometry.type.includes("Box") && c.position.y < 1) c.material.color.setHex(0xeeeeee);
                    else c.material.color.setHex(0xd0d0d0);
                } 
            });
        });
    }, CONFIG.powerModeDuration);
}

function updateGameLogic() {
    // 1. Player
    if (joystickData.active) {
        const speed = CONFIG.moveSpeed;
        const tx = player.position.x + joystickData.x * speed;
        const tz = player.position.z + joystickData.y * speed;
        if(!checkWall(tx, player.position.z)) player.position.x = tx;
        if(!checkWall(player.position.x, tz)) player.position.z = tz;
        if (Math.abs(joystickData.x) > 0.1 || Math.abs(joystickData.y) > 0.1) {
            player.rotation.y = Math.atan2(joystickData.x, joystickData.y);
        }
        socket.emit('playerMove', { room: myRoomId, x: player.position.x, z: player.position.z, rotation: player.rotation.y });
    }

    // 2. Remote Players
    for(const id in remotePlayers) {
        const rp = remotePlayers[id];
        if(rp.targetPos) {
            rp.mesh.position.x += (rp.targetPos.x - rp.mesh.position.x) * 0.2;
            rp.mesh.position.z += (rp.targetPos.z - rp.mesh.position.z) * 0.2;
            rp.mesh.rotation.y = rp.targetPos.rot;
            
            const vec = rp.mesh.position.clone(); vec.y += 2.5; vec.project(camera);
            const x = (vec.x * .5 + .5) * window.innerWidth;
            const y = (-(vec.y * .5) + .5) * window.innerHeight;
            if (Math.abs(vec.z) < 1) {
                rp.label.style.display = 'block'; rp.label.style.left = x + 'px'; rp.label.style.top = y + 'px';
            } else rp.label.style.display = 'none';
        }
    }

    // 3. Items
    pellets.forEach(p => {
        if(p.visible && player.position.distanceTo(p.position) < 1.0) {
            p.visible = false; socket.emit('itemCollected', { room: myRoomId, type: 'pellet', index: p.userData.index });
        }
    });
    crucifixes.forEach(c => {
         if(c.visible && player.position.distanceTo(c.position) < 1.5) {
            c.visible = false; socket.emit('itemCollected', { room: myRoomId, type: 'crucifix', index: c.userData.index });
        }
    });

    // 4. Host Logic
    if (isHost && ghosts.length > 0) {
        const ghostUpdates = [];
        const layout = MAPS[(currentState.level-1)%MAPS.length];
        
        ghosts.forEach((g, i) => {
            if(!g.visible) return;
            // Simple Move towards nearest player
            let target = player.position; 
            // Hier würde man eigentlich durch alle Players iterieren um den nächsten zu finden
            
            const dir = new THREE.Vector3().subVectors(target, g.position).normalize();
            const speed = CONFIG.baseGhostSpeed * 0.5; // Langsamer als Spieler
            
            let nx = g.position.x + dir.x * speed;
            let nz = g.position.z + dir.z * speed;
            
            // Wall Check for Ghost
            // (Vereinfacht: Geist gleitet an Wänden)
            if(!checkWall(nx, g.position.z)) g.position.x = nx;
            if(!checkWall(g.position.x, nz)) g.position.z = nz;

            ghostUpdates.push({ x: g.position.x, z: g.position.z, index: i });
            
            // Check Collision with players
             if(g.position.distanceTo(player.position) < 1.0) {
                 // Check if Power Mode -> Ghost Dies
                 const msg = document.getElementById('status-message');
                 if(msg.style.display === 'block') {
                     // Hacky check for power mode via UI state to simplify
                     socket.emit('ghostEliminated', { room: myRoomId, ghostId: i });
                 }
                 // Else Player Dies logic handled locally or by server?
                 // For now multiplayer permadeath is tricky, lets just ignore death or respawn player
             }
        });
        socket.emit('ghostsUpdate', { room: myRoomId, ghostsData: ghostUpdates });
    }
    
    // Check Level End (Host only really needs to trigger, but clients can check visual state)
    if(isHost) {
        let itemsLeft = pellets.some(p => p.visible) || crucifixes.some(c => c.visible);
        let ghostsLeft = ghosts.some(g => g.visible);
        if(!itemsLeft && !ghostsLeft) {
             socket.emit('levelFinished', { room: myRoomId });
        }
    }

    // Particles
    for(let i = particles.length -1; i>=0; i--) {
        const p = particles[i];
        p.position.add(new THREE.Vector3(p.userData.vx, p.userData.vy, p.userData.vz));
        p.userData.vy -= 0.01; p.userData.life -= 0.05; p.scale.setScalar(p.userData.life);
        if(p.userData.life <= 0) { scene.remove(p); particles.splice(i, 1); }
    }

    camera.position.x += (player.position.x - camera.position.x) * 0.1;
    camera.position.z += (player.position.z + 11 - camera.position.z) * 0.1;
    camera.lookAt(player.position);
}

function checkWall(x, z) {
    for(let w of walls) {
        const b = w.userData.box;
        if(x > b.min.x - 0.8 && x < b.max.x + 0.8 && z > b.min.z - 0.8 && z < b.max.z + 0.8) return true;
    }
    return false;
}

function setupJoystick() {
    const zone = document.getElementById('joystick-zone');
    const knob = document.getElementById('joystick-knob');
    const center = { x: 60, y: 60 };
    function handle(e) {
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
        const rect = zone.getBoundingClientRect();
        const dx = clientX - rect.left - center.x;
        const dy = clientY - rect.top - center.y;
        const dist = Math.min(Math.sqrt(dx*dx+dy*dy), 35);
        const ang = Math.atan2(dy, dx);
        joystickData.active = true;
        joystickData.x = (Math.cos(ang)*dist)/35;
        joystickData.y = (Math.sin(ang)*dist)/35;
        knob.style.transform = `translate(calc(-50% + ${Math.cos(ang)*dist}px), calc(-50% + ${Math.sin(ang)*dist}px))`;
    }
    zone.addEventListener('mousedown', e => { handle(e); zone.onmousemove = handle; });
    window.addEventListener('mouseup', () => { zone.onmousemove = null; joystickData.active=false; knob.style.transform='translate(-50%,-50%)'; });
    zone.addEventListener('touchstart', e => { e.preventDefault(); handle(e); });
    zone.addEventListener('touchmove', e => { e.preventDefault(); handle(e); });
    zone.addEventListener('touchend', () => { joystickData.active=false; knob.style.transform='translate(-50%,-50%)'; });
}

function onWindowResize() {
    camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
}

function animate() {
    requestAnimationFrame(animate);
    updateGameLogic();
    renderer.render(scene, camera);
    const oldFog = scene.fog; scene.fog = null; scene.add(mapLight);
    mapRenderer.render(scene, mapCamera);
    scene.remove(mapLight); scene.fog = oldFog;
}

</script>
</body>
</html>


